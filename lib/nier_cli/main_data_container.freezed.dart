// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'main_data_container.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$MainData {
  Map<String, dynamic> get argument => throw _privateConstructorUsedError;
  OptionIdentifier? get sortedEnemyGroupsIdentifierMap =>
      throw _privateConstructorUsedError;
  bool? get isManagerFile => throw _privateConstructorUsedError;
  String get output => throw _privateConstructorUsedError;
  ArgResults get args => throw _privateConstructorUsedError;
  SendPort get sendPort => throw _privateConstructorUsedError;
  bool? get backUp => throw _privateConstructorUsedError;
  bool? get isBalanceMode => throw _privateConstructorUsedError;
  bool? get hasDLC => throw _privateConstructorUsedError;
  bool get isAddition => throw _privateConstructorUsedError;

  /// Create a copy of MainData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $MainDataCopyWith<MainData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $MainDataCopyWith<$Res> {
  factory $MainDataCopyWith(MainData value, $Res Function(MainData) then) =
      _$MainDataCopyWithImpl<$Res, MainData>;
  @useResult
  $Res call(
      {Map<String, dynamic> argument,
      OptionIdentifier? sortedEnemyGroupsIdentifierMap,
      bool? isManagerFile,
      String output,
      ArgResults args,
      SendPort sendPort,
      bool? backUp,
      bool? isBalanceMode,
      bool? hasDLC,
      bool isAddition});

  $OptionIdentifierCopyWith<$Res>? get sortedEnemyGroupsIdentifierMap;
}

/// @nodoc
class _$MainDataCopyWithImpl<$Res, $Val extends MainData>
    implements $MainDataCopyWith<$Res> {
  _$MainDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of MainData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? argument = null,
    Object? sortedEnemyGroupsIdentifierMap = freezed,
    Object? isManagerFile = freezed,
    Object? output = null,
    Object? args = null,
    Object? sendPort = null,
    Object? backUp = freezed,
    Object? isBalanceMode = freezed,
    Object? hasDLC = freezed,
    Object? isAddition = null,
  }) {
    return _then(_value.copyWith(
      argument: null == argument
          ? _value.argument
          : argument // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      sortedEnemyGroupsIdentifierMap: freezed == sortedEnemyGroupsIdentifierMap
          ? _value.sortedEnemyGroupsIdentifierMap
          : sortedEnemyGroupsIdentifierMap // ignore: cast_nullable_to_non_nullable
              as OptionIdentifier?,
      isManagerFile: freezed == isManagerFile
          ? _value.isManagerFile
          : isManagerFile // ignore: cast_nullable_to_non_nullable
              as bool?,
      output: null == output
          ? _value.output
          : output // ignore: cast_nullable_to_non_nullable
              as String,
      args: null == args
          ? _value.args
          : args // ignore: cast_nullable_to_non_nullable
              as ArgResults,
      sendPort: null == sendPort
          ? _value.sendPort
          : sendPort // ignore: cast_nullable_to_non_nullable
              as SendPort,
      backUp: freezed == backUp
          ? _value.backUp
          : backUp // ignore: cast_nullable_to_non_nullable
              as bool?,
      isBalanceMode: freezed == isBalanceMode
          ? _value.isBalanceMode
          : isBalanceMode // ignore: cast_nullable_to_non_nullable
              as bool?,
      hasDLC: freezed == hasDLC
          ? _value.hasDLC
          : hasDLC // ignore: cast_nullable_to_non_nullable
              as bool?,
      isAddition: null == isAddition
          ? _value.isAddition
          : isAddition // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }

  /// Create a copy of MainData
  /// with the given fields replaced by the non-null parameter values.
  @override
  @pragma('vm:prefer-inline')
  $OptionIdentifierCopyWith<$Res>? get sortedEnemyGroupsIdentifierMap {
    if (_value.sortedEnemyGroupsIdentifierMap == null) {
      return null;
    }

    return $OptionIdentifierCopyWith<$Res>(
        _value.sortedEnemyGroupsIdentifierMap!, (value) {
      return _then(
          _value.copyWith(sortedEnemyGroupsIdentifierMap: value) as $Val);
    });
  }
}

/// @nodoc
abstract class _$$MainDataImplCopyWith<$Res>
    implements $MainDataCopyWith<$Res> {
  factory _$$MainDataImplCopyWith(
          _$MainDataImpl value, $Res Function(_$MainDataImpl) then) =
      __$$MainDataImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {Map<String, dynamic> argument,
      OptionIdentifier? sortedEnemyGroupsIdentifierMap,
      bool? isManagerFile,
      String output,
      ArgResults args,
      SendPort sendPort,
      bool? backUp,
      bool? isBalanceMode,
      bool? hasDLC,
      bool isAddition});

  @override
  $OptionIdentifierCopyWith<$Res>? get sortedEnemyGroupsIdentifierMap;
}

/// @nodoc
class __$$MainDataImplCopyWithImpl<$Res>
    extends _$MainDataCopyWithImpl<$Res, _$MainDataImpl>
    implements _$$MainDataImplCopyWith<$Res> {
  __$$MainDataImplCopyWithImpl(
      _$MainDataImpl _value, $Res Function(_$MainDataImpl) _then)
      : super(_value, _then);

  /// Create a copy of MainData
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? argument = null,
    Object? sortedEnemyGroupsIdentifierMap = freezed,
    Object? isManagerFile = freezed,
    Object? output = null,
    Object? args = null,
    Object? sendPort = null,
    Object? backUp = freezed,
    Object? isBalanceMode = freezed,
    Object? hasDLC = freezed,
    Object? isAddition = null,
  }) {
    return _then(_$MainDataImpl(
      argument: null == argument
          ? _value._argument
          : argument // ignore: cast_nullable_to_non_nullable
              as Map<String, dynamic>,
      sortedEnemyGroupsIdentifierMap: freezed == sortedEnemyGroupsIdentifierMap
          ? _value.sortedEnemyGroupsIdentifierMap
          : sortedEnemyGroupsIdentifierMap // ignore: cast_nullable_to_non_nullable
              as OptionIdentifier?,
      isManagerFile: freezed == isManagerFile
          ? _value.isManagerFile
          : isManagerFile // ignore: cast_nullable_to_non_nullable
              as bool?,
      output: null == output
          ? _value.output
          : output // ignore: cast_nullable_to_non_nullable
              as String,
      args: null == args
          ? _value.args
          : args // ignore: cast_nullable_to_non_nullable
              as ArgResults,
      sendPort: null == sendPort
          ? _value.sendPort
          : sendPort // ignore: cast_nullable_to_non_nullable
              as SendPort,
      backUp: freezed == backUp
          ? _value.backUp
          : backUp // ignore: cast_nullable_to_non_nullable
              as bool?,
      isBalanceMode: freezed == isBalanceMode
          ? _value.isBalanceMode
          : isBalanceMode // ignore: cast_nullable_to_non_nullable
              as bool?,
      hasDLC: freezed == hasDLC
          ? _value.hasDLC
          : hasDLC // ignore: cast_nullable_to_non_nullable
              as bool?,
      isAddition: null == isAddition
          ? _value.isAddition
          : isAddition // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$MainDataImpl implements _MainData {
  const _$MainDataImpl(
      {required final Map<String, dynamic> argument,
      this.sortedEnemyGroupsIdentifierMap,
      this.isManagerFile,
      required this.output,
      required this.args,
      required this.sendPort,
      this.backUp,
      this.isBalanceMode,
      this.hasDLC,
      required this.isAddition})
      : _argument = argument;

  final Map<String, dynamic> _argument;
  @override
  Map<String, dynamic> get argument {
    if (_argument is EqualUnmodifiableMapView) return _argument;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_argument);
  }

  @override
  final OptionIdentifier? sortedEnemyGroupsIdentifierMap;
  @override
  final bool? isManagerFile;
  @override
  final String output;
  @override
  final ArgResults args;
  @override
  final SendPort sendPort;
  @override
  final bool? backUp;
  @override
  final bool? isBalanceMode;
  @override
  final bool? hasDLC;
  @override
  final bool isAddition;

  @override
  String toString() {
    return 'MainData(argument: $argument, sortedEnemyGroupsIdentifierMap: $sortedEnemyGroupsIdentifierMap, isManagerFile: $isManagerFile, output: $output, args: $args, sendPort: $sendPort, backUp: $backUp, isBalanceMode: $isBalanceMode, hasDLC: $hasDLC, isAddition: $isAddition)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$MainDataImpl &&
            const DeepCollectionEquality().equals(other._argument, _argument) &&
            (identical(other.sortedEnemyGroupsIdentifierMap,
                    sortedEnemyGroupsIdentifierMap) ||
                other.sortedEnemyGroupsIdentifierMap ==
                    sortedEnemyGroupsIdentifierMap) &&
            (identical(other.isManagerFile, isManagerFile) ||
                other.isManagerFile == isManagerFile) &&
            (identical(other.output, output) || other.output == output) &&
            (identical(other.args, args) || other.args == args) &&
            (identical(other.sendPort, sendPort) ||
                other.sendPort == sendPort) &&
            (identical(other.backUp, backUp) || other.backUp == backUp) &&
            (identical(other.isBalanceMode, isBalanceMode) ||
                other.isBalanceMode == isBalanceMode) &&
            (identical(other.hasDLC, hasDLC) || other.hasDLC == hasDLC) &&
            (identical(other.isAddition, isAddition) ||
                other.isAddition == isAddition));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_argument),
      sortedEnemyGroupsIdentifierMap,
      isManagerFile,
      output,
      args,
      sendPort,
      backUp,
      isBalanceMode,
      hasDLC,
      isAddition);

  /// Create a copy of MainData
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$MainDataImplCopyWith<_$MainDataImpl> get copyWith =>
      __$$MainDataImplCopyWithImpl<_$MainDataImpl>(this, _$identity);
}

abstract class _MainData implements MainData {
  const factory _MainData(
      {required final Map<String, dynamic> argument,
      final OptionIdentifier? sortedEnemyGroupsIdentifierMap,
      final bool? isManagerFile,
      required final String output,
      required final ArgResults args,
      required final SendPort sendPort,
      final bool? backUp,
      final bool? isBalanceMode,
      final bool? hasDLC,
      required final bool isAddition}) = _$MainDataImpl;

  @override
  Map<String, dynamic> get argument;
  @override
  OptionIdentifier? get sortedEnemyGroupsIdentifierMap;
  @override
  bool? get isManagerFile;
  @override
  String get output;
  @override
  ArgResults get args;
  @override
  SendPort get sendPort;
  @override
  bool? get backUp;
  @override
  bool? get isBalanceMode;
  @override
  bool? get hasDLC;
  @override
  bool get isAddition;

  /// Create a copy of MainData
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$MainDataImplCopyWith<_$MainDataImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$NierCliArgs {
  List<String> get arguments => throw _privateConstructorUsedError;
  bool? get isManagerFile => throw _privateConstructorUsedError;
  SendPort get sendPort => throw _privateConstructorUsedError;
  bool? get backUp => throw _privateConstructorUsedError;
  bool? get isBalanceMode => throw _privateConstructorUsedError;
  bool? get hasDLC => throw _privateConstructorUsedError;
  bool get isAddition => throw _privateConstructorUsedError;

  /// Create a copy of NierCliArgs
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $NierCliArgsCopyWith<NierCliArgs> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $NierCliArgsCopyWith<$Res> {
  factory $NierCliArgsCopyWith(
          NierCliArgs value, $Res Function(NierCliArgs) then) =
      _$NierCliArgsCopyWithImpl<$Res, NierCliArgs>;
  @useResult
  $Res call(
      {List<String> arguments,
      bool? isManagerFile,
      SendPort sendPort,
      bool? backUp,
      bool? isBalanceMode,
      bool? hasDLC,
      bool isAddition});
}

/// @nodoc
class _$NierCliArgsCopyWithImpl<$Res, $Val extends NierCliArgs>
    implements $NierCliArgsCopyWith<$Res> {
  _$NierCliArgsCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of NierCliArgs
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? arguments = null,
    Object? isManagerFile = freezed,
    Object? sendPort = null,
    Object? backUp = freezed,
    Object? isBalanceMode = freezed,
    Object? hasDLC = freezed,
    Object? isAddition = null,
  }) {
    return _then(_value.copyWith(
      arguments: null == arguments
          ? _value.arguments
          : arguments // ignore: cast_nullable_to_non_nullable
              as List<String>,
      isManagerFile: freezed == isManagerFile
          ? _value.isManagerFile
          : isManagerFile // ignore: cast_nullable_to_non_nullable
              as bool?,
      sendPort: null == sendPort
          ? _value.sendPort
          : sendPort // ignore: cast_nullable_to_non_nullable
              as SendPort,
      backUp: freezed == backUp
          ? _value.backUp
          : backUp // ignore: cast_nullable_to_non_nullable
              as bool?,
      isBalanceMode: freezed == isBalanceMode
          ? _value.isBalanceMode
          : isBalanceMode // ignore: cast_nullable_to_non_nullable
              as bool?,
      hasDLC: freezed == hasDLC
          ? _value.hasDLC
          : hasDLC // ignore: cast_nullable_to_non_nullable
              as bool?,
      isAddition: null == isAddition
          ? _value.isAddition
          : isAddition // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$NierCliArgsImplCopyWith<$Res>
    implements $NierCliArgsCopyWith<$Res> {
  factory _$$NierCliArgsImplCopyWith(
          _$NierCliArgsImpl value, $Res Function(_$NierCliArgsImpl) then) =
      __$$NierCliArgsImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {List<String> arguments,
      bool? isManagerFile,
      SendPort sendPort,
      bool? backUp,
      bool? isBalanceMode,
      bool? hasDLC,
      bool isAddition});
}

/// @nodoc
class __$$NierCliArgsImplCopyWithImpl<$Res>
    extends _$NierCliArgsCopyWithImpl<$Res, _$NierCliArgsImpl>
    implements _$$NierCliArgsImplCopyWith<$Res> {
  __$$NierCliArgsImplCopyWithImpl(
      _$NierCliArgsImpl _value, $Res Function(_$NierCliArgsImpl) _then)
      : super(_value, _then);

  /// Create a copy of NierCliArgs
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? arguments = null,
    Object? isManagerFile = freezed,
    Object? sendPort = null,
    Object? backUp = freezed,
    Object? isBalanceMode = freezed,
    Object? hasDLC = freezed,
    Object? isAddition = null,
  }) {
    return _then(_$NierCliArgsImpl(
      arguments: null == arguments
          ? _value._arguments
          : arguments // ignore: cast_nullable_to_non_nullable
              as List<String>,
      isManagerFile: freezed == isManagerFile
          ? _value.isManagerFile
          : isManagerFile // ignore: cast_nullable_to_non_nullable
              as bool?,
      sendPort: null == sendPort
          ? _value.sendPort
          : sendPort // ignore: cast_nullable_to_non_nullable
              as SendPort,
      backUp: freezed == backUp
          ? _value.backUp
          : backUp // ignore: cast_nullable_to_non_nullable
              as bool?,
      isBalanceMode: freezed == isBalanceMode
          ? _value.isBalanceMode
          : isBalanceMode // ignore: cast_nullable_to_non_nullable
              as bool?,
      hasDLC: freezed == hasDLC
          ? _value.hasDLC
          : hasDLC // ignore: cast_nullable_to_non_nullable
              as bool?,
      isAddition: null == isAddition
          ? _value.isAddition
          : isAddition // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$NierCliArgsImpl implements _NierCliArgs {
  const _$NierCliArgsImpl(
      {required final List<String> arguments,
      this.isManagerFile,
      required this.sendPort,
      this.backUp,
      this.isBalanceMode,
      this.hasDLC,
      required this.isAddition})
      : _arguments = arguments;

  final List<String> _arguments;
  @override
  List<String> get arguments {
    if (_arguments is EqualUnmodifiableListView) return _arguments;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_arguments);
  }

  @override
  final bool? isManagerFile;
  @override
  final SendPort sendPort;
  @override
  final bool? backUp;
  @override
  final bool? isBalanceMode;
  @override
  final bool? hasDLC;
  @override
  final bool isAddition;

  @override
  String toString() {
    return 'NierCliArgs(arguments: $arguments, isManagerFile: $isManagerFile, sendPort: $sendPort, backUp: $backUp, isBalanceMode: $isBalanceMode, hasDLC: $hasDLC, isAddition: $isAddition)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$NierCliArgsImpl &&
            const DeepCollectionEquality()
                .equals(other._arguments, _arguments) &&
            (identical(other.isManagerFile, isManagerFile) ||
                other.isManagerFile == isManagerFile) &&
            (identical(other.sendPort, sendPort) ||
                other.sendPort == sendPort) &&
            (identical(other.backUp, backUp) || other.backUp == backUp) &&
            (identical(other.isBalanceMode, isBalanceMode) ||
                other.isBalanceMode == isBalanceMode) &&
            (identical(other.hasDLC, hasDLC) || other.hasDLC == hasDLC) &&
            (identical(other.isAddition, isAddition) ||
                other.isAddition == isAddition));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_arguments),
      isManagerFile,
      sendPort,
      backUp,
      isBalanceMode,
      hasDLC,
      isAddition);

  /// Create a copy of NierCliArgs
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$NierCliArgsImplCopyWith<_$NierCliArgsImpl> get copyWith =>
      __$$NierCliArgsImplCopyWithImpl<_$NierCliArgsImpl>(this, _$identity);
}

abstract class _NierCliArgs implements NierCliArgs {
  const factory _NierCliArgs(
      {required final List<String> arguments,
      final bool? isManagerFile,
      required final SendPort sendPort,
      final bool? backUp,
      final bool? isBalanceMode,
      final bool? hasDLC,
      required final bool isAddition}) = _$NierCliArgsImpl;

  @override
  List<String> get arguments;
  @override
  bool? get isManagerFile;
  @override
  SendPort get sendPort;
  @override
  bool? get backUp;
  @override
  bool? get isBalanceMode;
  @override
  bool? get hasDLC;
  @override
  bool get isAddition;

  /// Create a copy of NierCliArgs
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$NierCliArgsImplCopyWith<_$NierCliArgsImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$EnemyEntityObjectAction {
  xml.XmlElement get objIdElement => throw _privateConstructorUsedError;
  Map<String, List<String>> get userSelectedEnemyData =>
      throw _privateConstructorUsedError;
  String get enemyLevel => throw _privateConstructorUsedError;
  bool get isSpawnActionTooSmall => throw _privateConstructorUsedError;
  bool get handleLevels => throw _privateConstructorUsedError;
  bool get randomizeAndSetValues => throw _privateConstructorUsedError;

  /// Create a copy of EnemyEntityObjectAction
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $EnemyEntityObjectActionCopyWith<EnemyEntityObjectAction> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $EnemyEntityObjectActionCopyWith<$Res> {
  factory $EnemyEntityObjectActionCopyWith(EnemyEntityObjectAction value,
          $Res Function(EnemyEntityObjectAction) then) =
      _$EnemyEntityObjectActionCopyWithImpl<$Res, EnemyEntityObjectAction>;
  @useResult
  $Res call(
      {xml.XmlElement objIdElement,
      Map<String, List<String>> userSelectedEnemyData,
      String enemyLevel,
      bool isSpawnActionTooSmall,
      bool handleLevels,
      bool randomizeAndSetValues});
}

/// @nodoc
class _$EnemyEntityObjectActionCopyWithImpl<$Res,
        $Val extends EnemyEntityObjectAction>
    implements $EnemyEntityObjectActionCopyWith<$Res> {
  _$EnemyEntityObjectActionCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of EnemyEntityObjectAction
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? objIdElement = null,
    Object? userSelectedEnemyData = null,
    Object? enemyLevel = null,
    Object? isSpawnActionTooSmall = null,
    Object? handleLevels = null,
    Object? randomizeAndSetValues = null,
  }) {
    return _then(_value.copyWith(
      objIdElement: null == objIdElement
          ? _value.objIdElement
          : objIdElement // ignore: cast_nullable_to_non_nullable
              as xml.XmlElement,
      userSelectedEnemyData: null == userSelectedEnemyData
          ? _value.userSelectedEnemyData
          : userSelectedEnemyData // ignore: cast_nullable_to_non_nullable
              as Map<String, List<String>>,
      enemyLevel: null == enemyLevel
          ? _value.enemyLevel
          : enemyLevel // ignore: cast_nullable_to_non_nullable
              as String,
      isSpawnActionTooSmall: null == isSpawnActionTooSmall
          ? _value.isSpawnActionTooSmall
          : isSpawnActionTooSmall // ignore: cast_nullable_to_non_nullable
              as bool,
      handleLevels: null == handleLevels
          ? _value.handleLevels
          : handleLevels // ignore: cast_nullable_to_non_nullable
              as bool,
      randomizeAndSetValues: null == randomizeAndSetValues
          ? _value.randomizeAndSetValues
          : randomizeAndSetValues // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$EnemyEntityObjectActionImplCopyWith<$Res>
    implements $EnemyEntityObjectActionCopyWith<$Res> {
  factory _$$EnemyEntityObjectActionImplCopyWith(
          _$EnemyEntityObjectActionImpl value,
          $Res Function(_$EnemyEntityObjectActionImpl) then) =
      __$$EnemyEntityObjectActionImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {xml.XmlElement objIdElement,
      Map<String, List<String>> userSelectedEnemyData,
      String enemyLevel,
      bool isSpawnActionTooSmall,
      bool handleLevels,
      bool randomizeAndSetValues});
}

/// @nodoc
class __$$EnemyEntityObjectActionImplCopyWithImpl<$Res>
    extends _$EnemyEntityObjectActionCopyWithImpl<$Res,
        _$EnemyEntityObjectActionImpl>
    implements _$$EnemyEntityObjectActionImplCopyWith<$Res> {
  __$$EnemyEntityObjectActionImplCopyWithImpl(
      _$EnemyEntityObjectActionImpl _value,
      $Res Function(_$EnemyEntityObjectActionImpl) _then)
      : super(_value, _then);

  /// Create a copy of EnemyEntityObjectAction
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? objIdElement = null,
    Object? userSelectedEnemyData = null,
    Object? enemyLevel = null,
    Object? isSpawnActionTooSmall = null,
    Object? handleLevels = null,
    Object? randomizeAndSetValues = null,
  }) {
    return _then(_$EnemyEntityObjectActionImpl(
      objIdElement: null == objIdElement
          ? _value.objIdElement
          : objIdElement // ignore: cast_nullable_to_non_nullable
              as xml.XmlElement,
      userSelectedEnemyData: null == userSelectedEnemyData
          ? _value._userSelectedEnemyData
          : userSelectedEnemyData // ignore: cast_nullable_to_non_nullable
              as Map<String, List<String>>,
      enemyLevel: null == enemyLevel
          ? _value.enemyLevel
          : enemyLevel // ignore: cast_nullable_to_non_nullable
              as String,
      isSpawnActionTooSmall: null == isSpawnActionTooSmall
          ? _value.isSpawnActionTooSmall
          : isSpawnActionTooSmall // ignore: cast_nullable_to_non_nullable
              as bool,
      handleLevels: null == handleLevels
          ? _value.handleLevels
          : handleLevels // ignore: cast_nullable_to_non_nullable
              as bool,
      randomizeAndSetValues: null == randomizeAndSetValues
          ? _value.randomizeAndSetValues
          : randomizeAndSetValues // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$EnemyEntityObjectActionImpl implements _EnemyEntityObjectAction {
  const _$EnemyEntityObjectActionImpl(
      {required this.objIdElement,
      required final Map<String, List<String>> userSelectedEnemyData,
      required this.enemyLevel,
      required this.isSpawnActionTooSmall,
      this.handleLevels = false,
      this.randomizeAndSetValues = false})
      : _userSelectedEnemyData = userSelectedEnemyData;

  @override
  final xml.XmlElement objIdElement;
  final Map<String, List<String>> _userSelectedEnemyData;
  @override
  Map<String, List<String>> get userSelectedEnemyData {
    if (_userSelectedEnemyData is EqualUnmodifiableMapView)
      return _userSelectedEnemyData;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_userSelectedEnemyData);
  }

  @override
  final String enemyLevel;
  @override
  final bool isSpawnActionTooSmall;
  @override
  @JsonKey()
  final bool handleLevels;
  @override
  @JsonKey()
  final bool randomizeAndSetValues;

  @override
  String toString() {
    return 'EnemyEntityObjectAction(objIdElement: $objIdElement, userSelectedEnemyData: $userSelectedEnemyData, enemyLevel: $enemyLevel, isSpawnActionTooSmall: $isSpawnActionTooSmall, handleLevels: $handleLevels, randomizeAndSetValues: $randomizeAndSetValues)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$EnemyEntityObjectActionImpl &&
            (identical(other.objIdElement, objIdElement) ||
                other.objIdElement == objIdElement) &&
            const DeepCollectionEquality()
                .equals(other._userSelectedEnemyData, _userSelectedEnemyData) &&
            (identical(other.enemyLevel, enemyLevel) ||
                other.enemyLevel == enemyLevel) &&
            (identical(other.isSpawnActionTooSmall, isSpawnActionTooSmall) ||
                other.isSpawnActionTooSmall == isSpawnActionTooSmall) &&
            (identical(other.handleLevels, handleLevels) ||
                other.handleLevels == handleLevels) &&
            (identical(other.randomizeAndSetValues, randomizeAndSetValues) ||
                other.randomizeAndSetValues == randomizeAndSetValues));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      objIdElement,
      const DeepCollectionEquality().hash(_userSelectedEnemyData),
      enemyLevel,
      isSpawnActionTooSmall,
      handleLevels,
      randomizeAndSetValues);

  /// Create a copy of EnemyEntityObjectAction
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$EnemyEntityObjectActionImplCopyWith<_$EnemyEntityObjectActionImpl>
      get copyWith => __$$EnemyEntityObjectActionImplCopyWithImpl<
          _$EnemyEntityObjectActionImpl>(this, _$identity);
}

abstract class _EnemyEntityObjectAction implements EnemyEntityObjectAction {
  const factory _EnemyEntityObjectAction(
      {required final xml.XmlElement objIdElement,
      required final Map<String, List<String>> userSelectedEnemyData,
      required final String enemyLevel,
      required final bool isSpawnActionTooSmall,
      final bool handleLevels,
      final bool randomizeAndSetValues}) = _$EnemyEntityObjectActionImpl;

  @override
  xml.XmlElement get objIdElement;
  @override
  Map<String, List<String>> get userSelectedEnemyData;
  @override
  String get enemyLevel;
  @override
  bool get isSpawnActionTooSmall;
  @override
  bool get handleLevels;
  @override
  bool get randomizeAndSetValues;

  /// Create a copy of EnemyEntityObjectAction
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$EnemyEntityObjectActionImplCopyWith<_$EnemyEntityObjectActionImpl>
      get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$OptionIdentifier {
  String get value => throw _privateConstructorUsedError;

  /// Create a copy of OptionIdentifier
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $OptionIdentifierCopyWith<OptionIdentifier> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $OptionIdentifierCopyWith<$Res> {
  factory $OptionIdentifierCopyWith(
          OptionIdentifier value, $Res Function(OptionIdentifier) then) =
      _$OptionIdentifierCopyWithImpl<$Res, OptionIdentifier>;
  @useResult
  $Res call({String value});
}

/// @nodoc
class _$OptionIdentifierCopyWithImpl<$Res, $Val extends OptionIdentifier>
    implements $OptionIdentifierCopyWith<$Res> {
  _$OptionIdentifierCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of OptionIdentifier
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_value.copyWith(
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$OptionIdentifierImplCopyWith<$Res>
    implements $OptionIdentifierCopyWith<$Res> {
  factory _$$OptionIdentifierImplCopyWith(_$OptionIdentifierImpl value,
          $Res Function(_$OptionIdentifierImpl) then) =
      __$$OptionIdentifierImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String value});
}

/// @nodoc
class __$$OptionIdentifierImplCopyWithImpl<$Res>
    extends _$OptionIdentifierCopyWithImpl<$Res, _$OptionIdentifierImpl>
    implements _$$OptionIdentifierImplCopyWith<$Res> {
  __$$OptionIdentifierImplCopyWithImpl(_$OptionIdentifierImpl _value,
      $Res Function(_$OptionIdentifierImpl) _then)
      : super(_value, _then);

  /// Create a copy of OptionIdentifier
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? value = null,
  }) {
    return _then(_$OptionIdentifierImpl(
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$OptionIdentifierImpl implements _OptionIdentifier {
  const _$OptionIdentifierImpl({required this.value});

  @override
  final String value;

  @override
  String toString() {
    return 'OptionIdentifier(value: $value)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$OptionIdentifierImpl &&
            (identical(other.value, value) || other.value == value));
  }

  @override
  int get hashCode => Object.hash(runtimeType, value);

  /// Create a copy of OptionIdentifier
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$OptionIdentifierImplCopyWith<_$OptionIdentifierImpl> get copyWith =>
      __$$OptionIdentifierImplCopyWithImpl<_$OptionIdentifierImpl>(
          this, _$identity);
}

abstract class _OptionIdentifier implements OptionIdentifier {
  const factory _OptionIdentifier({required final String value}) =
      _$OptionIdentifierImpl;

  @override
  String get value;

  /// Create a copy of OptionIdentifier
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$OptionIdentifierImplCopyWith<_$OptionIdentifierImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$ExtractedFiles {
  List<YaxFile> get yaxFiles => throw _privateConstructorUsedError;
  List<XmlFile> get xmlFiles => throw _privateConstructorUsedError;
  List<PakFolder> get pakFolders => throw _privateConstructorUsedError;
  List<DatFolder> get datFolders => throw _privateConstructorUsedError;
  List<CpkExtractedFolder> get cpkExtractedFolders =>
      throw _privateConstructorUsedError;

  /// Create a copy of ExtractedFiles
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $ExtractedFilesCopyWith<ExtractedFiles> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $ExtractedFilesCopyWith<$Res> {
  factory $ExtractedFilesCopyWith(
          ExtractedFiles value, $Res Function(ExtractedFiles) then) =
      _$ExtractedFilesCopyWithImpl<$Res, ExtractedFiles>;
  @useResult
  $Res call(
      {List<YaxFile> yaxFiles,
      List<XmlFile> xmlFiles,
      List<PakFolder> pakFolders,
      List<DatFolder> datFolders,
      List<CpkExtractedFolder> cpkExtractedFolders});
}

/// @nodoc
class _$ExtractedFilesCopyWithImpl<$Res, $Val extends ExtractedFiles>
    implements $ExtractedFilesCopyWith<$Res> {
  _$ExtractedFilesCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of ExtractedFiles
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? yaxFiles = null,
    Object? xmlFiles = null,
    Object? pakFolders = null,
    Object? datFolders = null,
    Object? cpkExtractedFolders = null,
  }) {
    return _then(_value.copyWith(
      yaxFiles: null == yaxFiles
          ? _value.yaxFiles
          : yaxFiles // ignore: cast_nullable_to_non_nullable
              as List<YaxFile>,
      xmlFiles: null == xmlFiles
          ? _value.xmlFiles
          : xmlFiles // ignore: cast_nullable_to_non_nullable
              as List<XmlFile>,
      pakFolders: null == pakFolders
          ? _value.pakFolders
          : pakFolders // ignore: cast_nullable_to_non_nullable
              as List<PakFolder>,
      datFolders: null == datFolders
          ? _value.datFolders
          : datFolders // ignore: cast_nullable_to_non_nullable
              as List<DatFolder>,
      cpkExtractedFolders: null == cpkExtractedFolders
          ? _value.cpkExtractedFolders
          : cpkExtractedFolders // ignore: cast_nullable_to_non_nullable
              as List<CpkExtractedFolder>,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$ExtractedFilesImplCopyWith<$Res>
    implements $ExtractedFilesCopyWith<$Res> {
  factory _$$ExtractedFilesImplCopyWith(_$ExtractedFilesImpl value,
          $Res Function(_$ExtractedFilesImpl) then) =
      __$$ExtractedFilesImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {List<YaxFile> yaxFiles,
      List<XmlFile> xmlFiles,
      List<PakFolder> pakFolders,
      List<DatFolder> datFolders,
      List<CpkExtractedFolder> cpkExtractedFolders});
}

/// @nodoc
class __$$ExtractedFilesImplCopyWithImpl<$Res>
    extends _$ExtractedFilesCopyWithImpl<$Res, _$ExtractedFilesImpl>
    implements _$$ExtractedFilesImplCopyWith<$Res> {
  __$$ExtractedFilesImplCopyWithImpl(
      _$ExtractedFilesImpl _value, $Res Function(_$ExtractedFilesImpl) _then)
      : super(_value, _then);

  /// Create a copy of ExtractedFiles
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? yaxFiles = null,
    Object? xmlFiles = null,
    Object? pakFolders = null,
    Object? datFolders = null,
    Object? cpkExtractedFolders = null,
  }) {
    return _then(_$ExtractedFilesImpl(
      yaxFiles: null == yaxFiles
          ? _value._yaxFiles
          : yaxFiles // ignore: cast_nullable_to_non_nullable
              as List<YaxFile>,
      xmlFiles: null == xmlFiles
          ? _value._xmlFiles
          : xmlFiles // ignore: cast_nullable_to_non_nullable
              as List<XmlFile>,
      pakFolders: null == pakFolders
          ? _value._pakFolders
          : pakFolders // ignore: cast_nullable_to_non_nullable
              as List<PakFolder>,
      datFolders: null == datFolders
          ? _value._datFolders
          : datFolders // ignore: cast_nullable_to_non_nullable
              as List<DatFolder>,
      cpkExtractedFolders: null == cpkExtractedFolders
          ? _value._cpkExtractedFolders
          : cpkExtractedFolders // ignore: cast_nullable_to_non_nullable
              as List<CpkExtractedFolder>,
    ));
  }
}

/// @nodoc

class _$ExtractedFilesImpl implements _ExtractedFiles {
  const _$ExtractedFilesImpl(
      {required final List<YaxFile> yaxFiles,
      required final List<XmlFile> xmlFiles,
      required final List<PakFolder> pakFolders,
      required final List<DatFolder> datFolders,
      required final List<CpkExtractedFolder> cpkExtractedFolders})
      : _yaxFiles = yaxFiles,
        _xmlFiles = xmlFiles,
        _pakFolders = pakFolders,
        _datFolders = datFolders,
        _cpkExtractedFolders = cpkExtractedFolders;

  final List<YaxFile> _yaxFiles;
  @override
  List<YaxFile> get yaxFiles {
    if (_yaxFiles is EqualUnmodifiableListView) return _yaxFiles;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_yaxFiles);
  }

  final List<XmlFile> _xmlFiles;
  @override
  List<XmlFile> get xmlFiles {
    if (_xmlFiles is EqualUnmodifiableListView) return _xmlFiles;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_xmlFiles);
  }

  final List<PakFolder> _pakFolders;
  @override
  List<PakFolder> get pakFolders {
    if (_pakFolders is EqualUnmodifiableListView) return _pakFolders;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_pakFolders);
  }

  final List<DatFolder> _datFolders;
  @override
  List<DatFolder> get datFolders {
    if (_datFolders is EqualUnmodifiableListView) return _datFolders;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_datFolders);
  }

  final List<CpkExtractedFolder> _cpkExtractedFolders;
  @override
  List<CpkExtractedFolder> get cpkExtractedFolders {
    if (_cpkExtractedFolders is EqualUnmodifiableListView)
      return _cpkExtractedFolders;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_cpkExtractedFolders);
  }

  @override
  String toString() {
    return 'ExtractedFiles(yaxFiles: $yaxFiles, xmlFiles: $xmlFiles, pakFolders: $pakFolders, datFolders: $datFolders, cpkExtractedFolders: $cpkExtractedFolders)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ExtractedFilesImpl &&
            const DeepCollectionEquality().equals(other._yaxFiles, _yaxFiles) &&
            const DeepCollectionEquality().equals(other._xmlFiles, _xmlFiles) &&
            const DeepCollectionEquality()
                .equals(other._pakFolders, _pakFolders) &&
            const DeepCollectionEquality()
                .equals(other._datFolders, _datFolders) &&
            const DeepCollectionEquality()
                .equals(other._cpkExtractedFolders, _cpkExtractedFolders));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_yaxFiles),
      const DeepCollectionEquality().hash(_xmlFiles),
      const DeepCollectionEquality().hash(_pakFolders),
      const DeepCollectionEquality().hash(_datFolders),
      const DeepCollectionEquality().hash(_cpkExtractedFolders));

  /// Create a copy of ExtractedFiles
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$ExtractedFilesImplCopyWith<_$ExtractedFilesImpl> get copyWith =>
      __$$ExtractedFilesImplCopyWithImpl<_$ExtractedFilesImpl>(
          this, _$identity);
}

abstract class _ExtractedFiles implements ExtractedFiles {
  const factory _ExtractedFiles(
          {required final List<YaxFile> yaxFiles,
          required final List<XmlFile> xmlFiles,
          required final List<PakFolder> pakFolders,
          required final List<DatFolder> datFolders,
          required final List<CpkExtractedFolder> cpkExtractedFolders}) =
      _$ExtractedFilesImpl;

  @override
  List<YaxFile> get yaxFiles;
  @override
  List<XmlFile> get xmlFiles;
  @override
  List<PakFolder> get pakFolders;
  @override
  List<DatFolder> get datFolders;
  @override
  List<CpkExtractedFolder> get cpkExtractedFolders;

  /// Create a copy of ExtractedFiles
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$ExtractedFilesImplCopyWith<_$ExtractedFilesImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$YaxFile {
  String get path => throw _privateConstructorUsedError;

  /// Create a copy of YaxFile
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $YaxFileCopyWith<YaxFile> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $YaxFileCopyWith<$Res> {
  factory $YaxFileCopyWith(YaxFile value, $Res Function(YaxFile) then) =
      _$YaxFileCopyWithImpl<$Res, YaxFile>;
  @useResult
  $Res call({String path});
}

/// @nodoc
class _$YaxFileCopyWithImpl<$Res, $Val extends YaxFile>
    implements $YaxFileCopyWith<$Res> {
  _$YaxFileCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of YaxFile
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? path = null,
  }) {
    return _then(_value.copyWith(
      path: null == path
          ? _value.path
          : path // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$YaxFileImplCopyWith<$Res> implements $YaxFileCopyWith<$Res> {
  factory _$$YaxFileImplCopyWith(
          _$YaxFileImpl value, $Res Function(_$YaxFileImpl) then) =
      __$$YaxFileImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String path});
}

/// @nodoc
class __$$YaxFileImplCopyWithImpl<$Res>
    extends _$YaxFileCopyWithImpl<$Res, _$YaxFileImpl>
    implements _$$YaxFileImplCopyWith<$Res> {
  __$$YaxFileImplCopyWithImpl(
      _$YaxFileImpl _value, $Res Function(_$YaxFileImpl) _then)
      : super(_value, _then);

  /// Create a copy of YaxFile
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? path = null,
  }) {
    return _then(_$YaxFileImpl(
      path: null == path
          ? _value.path
          : path // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$YaxFileImpl implements _YaxFile {
  const _$YaxFileImpl({required this.path});

  @override
  final String path;

  @override
  String toString() {
    return 'YaxFile(path: $path)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$YaxFileImpl &&
            (identical(other.path, path) || other.path == path));
  }

  @override
  int get hashCode => Object.hash(runtimeType, path);

  /// Create a copy of YaxFile
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$YaxFileImplCopyWith<_$YaxFileImpl> get copyWith =>
      __$$YaxFileImplCopyWithImpl<_$YaxFileImpl>(this, _$identity);
}

abstract class _YaxFile implements YaxFile {
  const factory _YaxFile({required final String path}) = _$YaxFileImpl;

  @override
  String get path;

  /// Create a copy of YaxFile
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$YaxFileImplCopyWith<_$YaxFileImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$XmlFile {
  String get path => throw _privateConstructorUsedError;

  /// Create a copy of XmlFile
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $XmlFileCopyWith<XmlFile> get copyWith => throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $XmlFileCopyWith<$Res> {
  factory $XmlFileCopyWith(XmlFile value, $Res Function(XmlFile) then) =
      _$XmlFileCopyWithImpl<$Res, XmlFile>;
  @useResult
  $Res call({String path});
}

/// @nodoc
class _$XmlFileCopyWithImpl<$Res, $Val extends XmlFile>
    implements $XmlFileCopyWith<$Res> {
  _$XmlFileCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of XmlFile
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? path = null,
  }) {
    return _then(_value.copyWith(
      path: null == path
          ? _value.path
          : path // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$XmlFileImplCopyWith<$Res> implements $XmlFileCopyWith<$Res> {
  factory _$$XmlFileImplCopyWith(
          _$XmlFileImpl value, $Res Function(_$XmlFileImpl) then) =
      __$$XmlFileImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String path});
}

/// @nodoc
class __$$XmlFileImplCopyWithImpl<$Res>
    extends _$XmlFileCopyWithImpl<$Res, _$XmlFileImpl>
    implements _$$XmlFileImplCopyWith<$Res> {
  __$$XmlFileImplCopyWithImpl(
      _$XmlFileImpl _value, $Res Function(_$XmlFileImpl) _then)
      : super(_value, _then);

  /// Create a copy of XmlFile
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? path = null,
  }) {
    return _then(_$XmlFileImpl(
      path: null == path
          ? _value.path
          : path // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$XmlFileImpl implements _XmlFile {
  const _$XmlFileImpl({required this.path});

  @override
  final String path;

  @override
  String toString() {
    return 'XmlFile(path: $path)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$XmlFileImpl &&
            (identical(other.path, path) || other.path == path));
  }

  @override
  int get hashCode => Object.hash(runtimeType, path);

  /// Create a copy of XmlFile
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$XmlFileImplCopyWith<_$XmlFileImpl> get copyWith =>
      __$$XmlFileImplCopyWithImpl<_$XmlFileImpl>(this, _$identity);
}

abstract class _XmlFile implements XmlFile {
  const factory _XmlFile({required final String path}) = _$XmlFileImpl;

  @override
  String get path;

  /// Create a copy of XmlFile
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$XmlFileImplCopyWith<_$XmlFileImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$PakFolder {
  String get path => throw _privateConstructorUsedError;

  /// Create a copy of PakFolder
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $PakFolderCopyWith<PakFolder> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $PakFolderCopyWith<$Res> {
  factory $PakFolderCopyWith(PakFolder value, $Res Function(PakFolder) then) =
      _$PakFolderCopyWithImpl<$Res, PakFolder>;
  @useResult
  $Res call({String path});
}

/// @nodoc
class _$PakFolderCopyWithImpl<$Res, $Val extends PakFolder>
    implements $PakFolderCopyWith<$Res> {
  _$PakFolderCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of PakFolder
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? path = null,
  }) {
    return _then(_value.copyWith(
      path: null == path
          ? _value.path
          : path // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$PakFolderImplCopyWith<$Res>
    implements $PakFolderCopyWith<$Res> {
  factory _$$PakFolderImplCopyWith(
          _$PakFolderImpl value, $Res Function(_$PakFolderImpl) then) =
      __$$PakFolderImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String path});
}

/// @nodoc
class __$$PakFolderImplCopyWithImpl<$Res>
    extends _$PakFolderCopyWithImpl<$Res, _$PakFolderImpl>
    implements _$$PakFolderImplCopyWith<$Res> {
  __$$PakFolderImplCopyWithImpl(
      _$PakFolderImpl _value, $Res Function(_$PakFolderImpl) _then)
      : super(_value, _then);

  /// Create a copy of PakFolder
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? path = null,
  }) {
    return _then(_$PakFolderImpl(
      path: null == path
          ? _value.path
          : path // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$PakFolderImpl implements _PakFolder {
  const _$PakFolderImpl({required this.path});

  @override
  final String path;

  @override
  String toString() {
    return 'PakFolder(path: $path)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PakFolderImpl &&
            (identical(other.path, path) || other.path == path));
  }

  @override
  int get hashCode => Object.hash(runtimeType, path);

  /// Create a copy of PakFolder
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$PakFolderImplCopyWith<_$PakFolderImpl> get copyWith =>
      __$$PakFolderImplCopyWithImpl<_$PakFolderImpl>(this, _$identity);
}

abstract class _PakFolder implements PakFolder {
  const factory _PakFolder({required final String path}) = _$PakFolderImpl;

  @override
  String get path;

  /// Create a copy of PakFolder
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$PakFolderImplCopyWith<_$PakFolderImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$DatFolder {
  String get path => throw _privateConstructorUsedError;

  /// Create a copy of DatFolder
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $DatFolderCopyWith<DatFolder> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DatFolderCopyWith<$Res> {
  factory $DatFolderCopyWith(DatFolder value, $Res Function(DatFolder) then) =
      _$DatFolderCopyWithImpl<$Res, DatFolder>;
  @useResult
  $Res call({String path});
}

/// @nodoc
class _$DatFolderCopyWithImpl<$Res, $Val extends DatFolder>
    implements $DatFolderCopyWith<$Res> {
  _$DatFolderCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of DatFolder
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? path = null,
  }) {
    return _then(_value.copyWith(
      path: null == path
          ? _value.path
          : path // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$DatFolderImplCopyWith<$Res>
    implements $DatFolderCopyWith<$Res> {
  factory _$$DatFolderImplCopyWith(
          _$DatFolderImpl value, $Res Function(_$DatFolderImpl) then) =
      __$$DatFolderImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String path});
}

/// @nodoc
class __$$DatFolderImplCopyWithImpl<$Res>
    extends _$DatFolderCopyWithImpl<$Res, _$DatFolderImpl>
    implements _$$DatFolderImplCopyWith<$Res> {
  __$$DatFolderImplCopyWithImpl(
      _$DatFolderImpl _value, $Res Function(_$DatFolderImpl) _then)
      : super(_value, _then);

  /// Create a copy of DatFolder
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? path = null,
  }) {
    return _then(_$DatFolderImpl(
      path: null == path
          ? _value.path
          : path // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$DatFolderImpl implements _DatFolder {
  const _$DatFolderImpl({required this.path});

  @override
  final String path;

  @override
  String toString() {
    return 'DatFolder(path: $path)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DatFolderImpl &&
            (identical(other.path, path) || other.path == path));
  }

  @override
  int get hashCode => Object.hash(runtimeType, path);

  /// Create a copy of DatFolder
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$DatFolderImplCopyWith<_$DatFolderImpl> get copyWith =>
      __$$DatFolderImplCopyWithImpl<_$DatFolderImpl>(this, _$identity);
}

abstract class _DatFolder implements DatFolder {
  const factory _DatFolder({required final String path}) = _$DatFolderImpl;

  @override
  String get path;

  /// Create a copy of DatFolder
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$DatFolderImplCopyWith<_$DatFolderImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$CpkExtractedFolder {
  String get path => throw _privateConstructorUsedError;

  /// Create a copy of CpkExtractedFolder
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $CpkExtractedFolderCopyWith<CpkExtractedFolder> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $CpkExtractedFolderCopyWith<$Res> {
  factory $CpkExtractedFolderCopyWith(
          CpkExtractedFolder value, $Res Function(CpkExtractedFolder) then) =
      _$CpkExtractedFolderCopyWithImpl<$Res, CpkExtractedFolder>;
  @useResult
  $Res call({String path});
}

/// @nodoc
class _$CpkExtractedFolderCopyWithImpl<$Res, $Val extends CpkExtractedFolder>
    implements $CpkExtractedFolderCopyWith<$Res> {
  _$CpkExtractedFolderCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of CpkExtractedFolder
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? path = null,
  }) {
    return _then(_value.copyWith(
      path: null == path
          ? _value.path
          : path // ignore: cast_nullable_to_non_nullable
              as String,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$CpkExtractedFolderImplCopyWith<$Res>
    implements $CpkExtractedFolderCopyWith<$Res> {
  factory _$$CpkExtractedFolderImplCopyWith(_$CpkExtractedFolderImpl value,
          $Res Function(_$CpkExtractedFolderImpl) then) =
      __$$CpkExtractedFolderImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({String path});
}

/// @nodoc
class __$$CpkExtractedFolderImplCopyWithImpl<$Res>
    extends _$CpkExtractedFolderCopyWithImpl<$Res, _$CpkExtractedFolderImpl>
    implements _$$CpkExtractedFolderImplCopyWith<$Res> {
  __$$CpkExtractedFolderImplCopyWithImpl(_$CpkExtractedFolderImpl _value,
      $Res Function(_$CpkExtractedFolderImpl) _then)
      : super(_value, _then);

  /// Create a copy of CpkExtractedFolder
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? path = null,
  }) {
    return _then(_$CpkExtractedFolderImpl(
      path: null == path
          ? _value.path
          : path // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$CpkExtractedFolderImpl implements _CpkExtractedFolder {
  const _$CpkExtractedFolderImpl({required this.path});

  @override
  final String path;

  @override
  String toString() {
    return 'CpkExtractedFolder(path: $path)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$CpkExtractedFolderImpl &&
            (identical(other.path, path) || other.path == path));
  }

  @override
  int get hashCode => Object.hash(runtimeType, path);

  /// Create a copy of CpkExtractedFolder
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$CpkExtractedFolderImplCopyWith<_$CpkExtractedFolderImpl> get copyWith =>
      __$$CpkExtractedFolderImplCopyWithImpl<_$CpkExtractedFolderImpl>(
          this, _$identity);
}

abstract class _CpkExtractedFolder implements CpkExtractedFolder {
  const factory _CpkExtractedFolder({required final String path}) =
      _$CpkExtractedFolderImpl;

  @override
  String get path;

  /// Create a copy of CpkExtractedFolder
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$CpkExtractedFolderImplCopyWith<_$CpkExtractedFolderImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
